// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: uba_job.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_uba_5fjob_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_uba_5fjob_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_uba_5fjob_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_uba_5fjob_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_uba_5fjob_2eproto;
class FLogLine;
struct FLogLineDefaultTypeInternal;
extern FLogLineDefaultTypeInternal _FLogLine_default_instance_;
class FUbaExit;
struct FUbaExitDefaultTypeInternal;
extern FUbaExitDefaultTypeInternal _FUbaExit_default_instance_;
class FUbaJob;
struct FUbaJobDefaultTypeInternal;
extern FUbaJobDefaultTypeInternal _FUbaJob_default_instance_;
class FUbaOutput;
struct FUbaOutputDefaultTypeInternal;
extern FUbaOutputDefaultTypeInternal _FUbaOutput_default_instance_;
class FUbaStats;
struct FUbaStatsDefaultTypeInternal;
extern FUbaStatsDefaultTypeInternal _FUbaStats_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::FLogLine* Arena::CreateMaybeMessage<::FLogLine>(Arena*);
template<> ::FUbaExit* Arena::CreateMaybeMessage<::FUbaExit>(Arena*);
template<> ::FUbaJob* Arena::CreateMaybeMessage<::FUbaJob>(Arena*);
template<> ::FUbaOutput* Arena::CreateMaybeMessage<::FUbaOutput>(Arena*);
template<> ::FUbaStats* Arena::CreateMaybeMessage<::FUbaStats>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ELogType : int {
  Lt_Error = 0,
  Lt_Warning = 1,
  Lt_Info = 2,
  Lt_Detail = 3,
  Lt_Debug = 4,
  ELogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ELogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ELogType_IsValid(int value);
constexpr ELogType ELogType_MIN = Lt_Error;
constexpr ELogType ELogType_MAX = Lt_Debug;
constexpr int ELogType_ARRAYSIZE = ELogType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELogType_descriptor();
template<typename T>
inline const std::string& ELogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELogType_descriptor(), enum_t_value);
}
inline bool ELogType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELogType>(
    ELogType_descriptor(), name, value);
}
// ===================================================================

class FUbaJob final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FUbaJob) */ {
 public:
  inline FUbaJob() : FUbaJob(nullptr) {}
  ~FUbaJob() override;
  explicit constexpr FUbaJob(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FUbaJob(const FUbaJob& from);
  FUbaJob(FUbaJob&& from) noexcept
    : FUbaJob() {
    *this = ::std::move(from);
  }

  inline FUbaJob& operator=(const FUbaJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline FUbaJob& operator=(FUbaJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FUbaJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const FUbaJob* internal_default_instance() {
    return reinterpret_cast<const FUbaJob*>(
               &_FUbaJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FUbaJob& a, FUbaJob& b) {
    a.Swap(&b);
  }
  inline void Swap(FUbaJob* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FUbaJob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FUbaJob* New() const final {
    return new FUbaJob();
  }

  FUbaJob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FUbaJob>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FUbaJob& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FUbaJob& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FUbaJob* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FUbaJob";
  }
  protected:
  explicit FUbaJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApplicationFieldNumber = 1,
    kArgumentsFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kWorkingDirFieldNumber = 4,
    kLogFileFieldNumber = 6,
    kInputFileFieldNumber = 7,
    kOutputFileFieldNumber = 8,
    kKnownInputsFieldNumber = 10,
    kBWriteOutputFilesOnFailFieldNumber = 5,
    kWeightFieldNumber = 9,
    kJobIdFieldNumber = 11,
  };
  // string application = 1;
  void clear_application();
  const std::string& application() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_application(ArgT0&& arg0, ArgT... args);
  std::string* mutable_application();
  PROTOBUF_MUST_USE_RESULT std::string* release_application();
  void set_allocated_application(std::string* application);
  private:
  const std::string& _internal_application() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_application(const std::string& value);
  std::string* _internal_mutable_application();
  public:

  // string arguments = 2;
  void clear_arguments();
  const std::string& arguments() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arguments(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arguments();
  PROTOBUF_MUST_USE_RESULT std::string* release_arguments();
  void set_allocated_arguments(std::string* arguments);
  private:
  const std::string& _internal_arguments() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arguments(const std::string& value);
  std::string* _internal_mutable_arguments();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string workingDir = 4;
  void clear_workingdir();
  const std::string& workingdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workingdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workingdir();
  PROTOBUF_MUST_USE_RESULT std::string* release_workingdir();
  void set_allocated_workingdir(std::string* workingdir);
  private:
  const std::string& _internal_workingdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workingdir(const std::string& value);
  std::string* _internal_mutable_workingdir();
  public:

  // string logFile = 6;
  void clear_logfile();
  const std::string& logfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logfile();
  PROTOBUF_MUST_USE_RESULT std::string* release_logfile();
  void set_allocated_logfile(std::string* logfile);
  private:
  const std::string& _internal_logfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logfile(const std::string& value);
  std::string* _internal_mutable_logfile();
  public:

  // string inputFile = 7;
  void clear_inputfile();
  const std::string& inputfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inputfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inputfile();
  PROTOBUF_MUST_USE_RESULT std::string* release_inputfile();
  void set_allocated_inputfile(std::string* inputfile);
  private:
  const std::string& _internal_inputfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inputfile(const std::string& value);
  std::string* _internal_mutable_inputfile();
  public:

  // string OutputFile = 8;
  void clear_outputfile();
  const std::string& outputfile() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_outputfile(ArgT0&& arg0, ArgT... args);
  std::string* mutable_outputfile();
  PROTOBUF_MUST_USE_RESULT std::string* release_outputfile();
  void set_allocated_outputfile(std::string* outputfile);
  private:
  const std::string& _internal_outputfile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_outputfile(const std::string& value);
  std::string* _internal_mutable_outputfile();
  public:

  // string knownInputs = 10;
  void clear_knowninputs();
  const std::string& knowninputs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_knowninputs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_knowninputs();
  PROTOBUF_MUST_USE_RESULT std::string* release_knowninputs();
  void set_allocated_knowninputs(std::string* knowninputs);
  private:
  const std::string& _internal_knowninputs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_knowninputs(const std::string& value);
  std::string* _internal_mutable_knowninputs();
  public:

  // bool bWriteOutputFilesOnFail = 5;
  void clear_bwriteoutputfilesonfail();
  bool bwriteoutputfilesonfail() const;
  void set_bwriteoutputfilesonfail(bool value);
  private:
  bool _internal_bwriteoutputfilesonfail() const;
  void _internal_set_bwriteoutputfilesonfail(bool value);
  public:

  // float weight = 9;
  void clear_weight();
  float weight() const;
  void set_weight(float value);
  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);
  public:

  // int32 jobId = 11;
  void clear_jobid();
  ::PROTOBUF_NAMESPACE_ID::int32 jobid() const;
  void set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_jobid() const;
  void _internal_set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:FUbaJob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr application_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workingdir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logfile_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inputfile_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr outputfile_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr knowninputs_;
  bool bwriteoutputfilesonfail_;
  float weight_;
  ::PROTOBUF_NAMESPACE_ID::int32 jobid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uba_5fjob_2eproto;
};
// -------------------------------------------------------------------

class FLogLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FLogLine) */ {
 public:
  inline FLogLine() : FLogLine(nullptr) {}
  ~FLogLine() override;
  explicit constexpr FLogLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FLogLine(const FLogLine& from);
  FLogLine(FLogLine&& from) noexcept
    : FLogLine() {
    *this = ::std::move(from);
  }

  inline FLogLine& operator=(const FLogLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline FLogLine& operator=(FLogLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FLogLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const FLogLine* internal_default_instance() {
    return reinterpret_cast<const FLogLine*>(
               &_FLogLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FLogLine& a, FLogLine& b) {
    a.Swap(&b);
  }
  inline void Swap(FLogLine* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FLogLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FLogLine* New() const final {
    return new FLogLine();
  }

  FLogLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FLogLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FLogLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FLogLine& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FLogLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FLogLine";
  }
  protected:
  explicit FLogLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .ELogType type = 2;
  void clear_type();
  ::ELogType type() const;
  void set_type(::ELogType value);
  private:
  ::ELogType _internal_type() const;
  void _internal_set_type(::ELogType value);
  public:

  // @@protoc_insertion_point(class_scope:FLogLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uba_5fjob_2eproto;
};
// -------------------------------------------------------------------

class FUbaStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FUbaStats) */ {
 public:
  inline FUbaStats() : FUbaStats(nullptr) {}
  ~FUbaStats() override;
  explicit constexpr FUbaStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FUbaStats(const FUbaStats& from);
  FUbaStats(FUbaStats&& from) noexcept
    : FUbaStats() {
    *this = ::std::move(from);
  }

  inline FUbaStats& operator=(const FUbaStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline FUbaStats& operator=(FUbaStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FUbaStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const FUbaStats* internal_default_instance() {
    return reinterpret_cast<const FUbaStats*>(
               &_FUbaStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FUbaStats& a, FUbaStats& b) {
    a.Swap(&b);
  }
  inline void Swap(FUbaStats* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FUbaStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FUbaStats* New() const final {
    return new FUbaStats();
  }

  FUbaStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FUbaStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FUbaStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FUbaStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FUbaStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FUbaStats";
  }
  protected:
  explicit FUbaStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueuedFieldNumber = 1,
    kActiveLocalFieldNumber = 2,
    kActiveRemoteFieldNumber = 3,
    kFinishedFieldNumber = 4,
  };
  // uint32 queued = 1;
  void clear_queued();
  ::PROTOBUF_NAMESPACE_ID::uint32 queued() const;
  void set_queued(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_queued() const;
  void _internal_set_queued(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 activeLocal = 2;
  void clear_activelocal();
  ::PROTOBUF_NAMESPACE_ID::uint32 activelocal() const;
  void set_activelocal(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_activelocal() const;
  void _internal_set_activelocal(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 activeRemote = 3;
  void clear_activeremote();
  ::PROTOBUF_NAMESPACE_ID::uint32 activeremote() const;
  void set_activeremote(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_activeremote() const;
  void _internal_set_activeremote(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 finished = 4;
  void clear_finished();
  ::PROTOBUF_NAMESPACE_ID::uint32 finished() const;
  void set_finished(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_finished() const;
  void _internal_set_finished(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:FUbaStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 queued_;
  ::PROTOBUF_NAMESPACE_ID::uint32 activelocal_;
  ::PROTOBUF_NAMESPACE_ID::uint32 activeremote_;
  ::PROTOBUF_NAMESPACE_ID::uint32 finished_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uba_5fjob_2eproto;
};
// -------------------------------------------------------------------

class FUbaOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FUbaOutput) */ {
 public:
  inline FUbaOutput() : FUbaOutput(nullptr) {}
  ~FUbaOutput() override;
  explicit constexpr FUbaOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FUbaOutput(const FUbaOutput& from);
  FUbaOutput(FUbaOutput&& from) noexcept
    : FUbaOutput() {
    *this = ::std::move(from);
  }

  inline FUbaOutput& operator=(const FUbaOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline FUbaOutput& operator=(FUbaOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FUbaOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const FUbaOutput* internal_default_instance() {
    return reinterpret_cast<const FUbaOutput*>(
               &_FUbaOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FUbaOutput& a, FUbaOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(FUbaOutput* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FUbaOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FUbaOutput* New() const final {
    return new FUbaOutput();
  }

  FUbaOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FUbaOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FUbaOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FUbaOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FUbaOutput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FUbaOutput";
  }
  protected:
  explicit FUbaOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 2,
    kStatsFieldNumber = 3,
    kExitCodeFieldNumber = 1,
    kJobIdFieldNumber = 4,
  };
  // string outputs = 2;
  void clear_outputs();
  const std::string& outputs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_outputs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_outputs();
  PROTOBUF_MUST_USE_RESULT std::string* release_outputs();
  void set_allocated_outputs(std::string* outputs);
  private:
  const std::string& _internal_outputs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_outputs(const std::string& value);
  std::string* _internal_mutable_outputs();
  public:

  // .FUbaStats stats = 3;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::FUbaStats& stats() const;
  PROTOBUF_MUST_USE_RESULT ::FUbaStats* release_stats();
  ::FUbaStats* mutable_stats();
  void set_allocated_stats(::FUbaStats* stats);
  private:
  const ::FUbaStats& _internal_stats() const;
  ::FUbaStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::FUbaStats* stats);
  ::FUbaStats* unsafe_arena_release_stats();

  // int32 exitCode = 1;
  void clear_exitcode();
  ::PROTOBUF_NAMESPACE_ID::int32 exitcode() const;
  void set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exitcode() const;
  void _internal_set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 jobId = 4;
  void clear_jobid();
  ::PROTOBUF_NAMESPACE_ID::int32 jobid() const;
  void set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_jobid() const;
  void _internal_set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:FUbaOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr outputs_;
  ::FUbaStats* stats_;
  ::PROTOBUF_NAMESPACE_ID::int32 exitcode_;
  ::PROTOBUF_NAMESPACE_ID::int32 jobid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uba_5fjob_2eproto;
};
// -------------------------------------------------------------------

class FUbaExit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FUbaExit) */ {
 public:
  inline FUbaExit() : FUbaExit(nullptr) {}
  ~FUbaExit() override;
  explicit constexpr FUbaExit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FUbaExit(const FUbaExit& from);
  FUbaExit(FUbaExit&& from) noexcept
    : FUbaExit() {
    *this = ::std::move(from);
  }

  inline FUbaExit& operator=(const FUbaExit& from) {
    CopyFrom(from);
    return *this;
  }
  inline FUbaExit& operator=(FUbaExit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FUbaExit& default_instance() {
    return *internal_default_instance();
  }
  static inline const FUbaExit* internal_default_instance() {
    return reinterpret_cast<const FUbaExit*>(
               &_FUbaExit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FUbaExit& a, FUbaExit& b) {
    a.Swap(&b);
  }
  inline void Swap(FUbaExit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FUbaExit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FUbaExit* New() const final {
    return new FUbaExit();
  }

  FUbaExit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FUbaExit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FUbaExit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FUbaExit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FUbaExit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FUbaExit";
  }
  protected:
  explicit FUbaExit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBExitFieldNumber = 1,
  };
  // bool bExit = 1;
  void clear_bexit();
  bool bexit() const;
  void set_bexit(bool value);
  private:
  bool _internal_bexit() const;
  void _internal_set_bexit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:FUbaExit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool bexit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uba_5fjob_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FUbaJob

// string application = 1;
inline void FUbaJob::clear_application() {
  application_.ClearToEmpty();
}
inline const std::string& FUbaJob::application() const {
  // @@protoc_insertion_point(field_get:FUbaJob.application)
  return _internal_application();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_application(ArgT0&& arg0, ArgT... args) {
 
 application_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.application)
}
inline std::string* FUbaJob::mutable_application() {
  std::string* _s = _internal_mutable_application();
  // @@protoc_insertion_point(field_mutable:FUbaJob.application)
  return _s;
}
inline const std::string& FUbaJob::_internal_application() const {
  return application_.Get();
}
inline void FUbaJob::_internal_set_application(const std::string& value) {
  
  application_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_application() {
  
  return application_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_application() {
  // @@protoc_insertion_point(field_release:FUbaJob.application)
  return application_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_application(std::string* application) {
  if (application != nullptr) {
    
  } else {
    
  }
  application_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), application,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.application)
}

// string arguments = 2;
inline void FUbaJob::clear_arguments() {
  arguments_.ClearToEmpty();
}
inline const std::string& FUbaJob::arguments() const {
  // @@protoc_insertion_point(field_get:FUbaJob.arguments)
  return _internal_arguments();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_arguments(ArgT0&& arg0, ArgT... args) {
 
 arguments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.arguments)
}
inline std::string* FUbaJob::mutable_arguments() {
  std::string* _s = _internal_mutable_arguments();
  // @@protoc_insertion_point(field_mutable:FUbaJob.arguments)
  return _s;
}
inline const std::string& FUbaJob::_internal_arguments() const {
  return arguments_.Get();
}
inline void FUbaJob::_internal_set_arguments(const std::string& value) {
  
  arguments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_arguments() {
  
  return arguments_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_arguments() {
  // @@protoc_insertion_point(field_release:FUbaJob.arguments)
  return arguments_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_arguments(std::string* arguments) {
  if (arguments != nullptr) {
    
  } else {
    
  }
  arguments_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arguments,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.arguments)
}

// string description = 3;
inline void FUbaJob::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& FUbaJob::description() const {
  // @@protoc_insertion_point(field_get:FUbaJob.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.description)
}
inline std::string* FUbaJob::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:FUbaJob.description)
  return _s;
}
inline const std::string& FUbaJob::_internal_description() const {
  return description_.Get();
}
inline void FUbaJob::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_description() {
  // @@protoc_insertion_point(field_release:FUbaJob.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.description)
}

// string workingDir = 4;
inline void FUbaJob::clear_workingdir() {
  workingdir_.ClearToEmpty();
}
inline const std::string& FUbaJob::workingdir() const {
  // @@protoc_insertion_point(field_get:FUbaJob.workingDir)
  return _internal_workingdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_workingdir(ArgT0&& arg0, ArgT... args) {
 
 workingdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.workingDir)
}
inline std::string* FUbaJob::mutable_workingdir() {
  std::string* _s = _internal_mutable_workingdir();
  // @@protoc_insertion_point(field_mutable:FUbaJob.workingDir)
  return _s;
}
inline const std::string& FUbaJob::_internal_workingdir() const {
  return workingdir_.Get();
}
inline void FUbaJob::_internal_set_workingdir(const std::string& value) {
  
  workingdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_workingdir() {
  
  return workingdir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_workingdir() {
  // @@protoc_insertion_point(field_release:FUbaJob.workingDir)
  return workingdir_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_workingdir(std::string* workingdir) {
  if (workingdir != nullptr) {
    
  } else {
    
  }
  workingdir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workingdir,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.workingDir)
}

// bool bWriteOutputFilesOnFail = 5;
inline void FUbaJob::clear_bwriteoutputfilesonfail() {
  bwriteoutputfilesonfail_ = false;
}
inline bool FUbaJob::_internal_bwriteoutputfilesonfail() const {
  return bwriteoutputfilesonfail_;
}
inline bool FUbaJob::bwriteoutputfilesonfail() const {
  // @@protoc_insertion_point(field_get:FUbaJob.bWriteOutputFilesOnFail)
  return _internal_bwriteoutputfilesonfail();
}
inline void FUbaJob::_internal_set_bwriteoutputfilesonfail(bool value) {
  
  bwriteoutputfilesonfail_ = value;
}
inline void FUbaJob::set_bwriteoutputfilesonfail(bool value) {
  _internal_set_bwriteoutputfilesonfail(value);
  // @@protoc_insertion_point(field_set:FUbaJob.bWriteOutputFilesOnFail)
}

// string logFile = 6;
inline void FUbaJob::clear_logfile() {
  logfile_.ClearToEmpty();
}
inline const std::string& FUbaJob::logfile() const {
  // @@protoc_insertion_point(field_get:FUbaJob.logFile)
  return _internal_logfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_logfile(ArgT0&& arg0, ArgT... args) {
 
 logfile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.logFile)
}
inline std::string* FUbaJob::mutable_logfile() {
  std::string* _s = _internal_mutable_logfile();
  // @@protoc_insertion_point(field_mutable:FUbaJob.logFile)
  return _s;
}
inline const std::string& FUbaJob::_internal_logfile() const {
  return logfile_.Get();
}
inline void FUbaJob::_internal_set_logfile(const std::string& value) {
  
  logfile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_logfile() {
  
  return logfile_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_logfile() {
  // @@protoc_insertion_point(field_release:FUbaJob.logFile)
  return logfile_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_logfile(std::string* logfile) {
  if (logfile != nullptr) {
    
  } else {
    
  }
  logfile_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logfile,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.logFile)
}

// string inputFile = 7;
inline void FUbaJob::clear_inputfile() {
  inputfile_.ClearToEmpty();
}
inline const std::string& FUbaJob::inputfile() const {
  // @@protoc_insertion_point(field_get:FUbaJob.inputFile)
  return _internal_inputfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_inputfile(ArgT0&& arg0, ArgT... args) {
 
 inputfile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.inputFile)
}
inline std::string* FUbaJob::mutable_inputfile() {
  std::string* _s = _internal_mutable_inputfile();
  // @@protoc_insertion_point(field_mutable:FUbaJob.inputFile)
  return _s;
}
inline const std::string& FUbaJob::_internal_inputfile() const {
  return inputfile_.Get();
}
inline void FUbaJob::_internal_set_inputfile(const std::string& value) {
  
  inputfile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_inputfile() {
  
  return inputfile_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_inputfile() {
  // @@protoc_insertion_point(field_release:FUbaJob.inputFile)
  return inputfile_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_inputfile(std::string* inputfile) {
  if (inputfile != nullptr) {
    
  } else {
    
  }
  inputfile_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), inputfile,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.inputFile)
}

// string OutputFile = 8;
inline void FUbaJob::clear_outputfile() {
  outputfile_.ClearToEmpty();
}
inline const std::string& FUbaJob::outputfile() const {
  // @@protoc_insertion_point(field_get:FUbaJob.OutputFile)
  return _internal_outputfile();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_outputfile(ArgT0&& arg0, ArgT... args) {
 
 outputfile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.OutputFile)
}
inline std::string* FUbaJob::mutable_outputfile() {
  std::string* _s = _internal_mutable_outputfile();
  // @@protoc_insertion_point(field_mutable:FUbaJob.OutputFile)
  return _s;
}
inline const std::string& FUbaJob::_internal_outputfile() const {
  return outputfile_.Get();
}
inline void FUbaJob::_internal_set_outputfile(const std::string& value) {
  
  outputfile_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_outputfile() {
  
  return outputfile_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_outputfile() {
  // @@protoc_insertion_point(field_release:FUbaJob.OutputFile)
  return outputfile_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_outputfile(std::string* outputfile) {
  if (outputfile != nullptr) {
    
  } else {
    
  }
  outputfile_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), outputfile,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.OutputFile)
}

// float weight = 9;
inline void FUbaJob::clear_weight() {
  weight_ = 0;
}
inline float FUbaJob::_internal_weight() const {
  return weight_;
}
inline float FUbaJob::weight() const {
  // @@protoc_insertion_point(field_get:FUbaJob.weight)
  return _internal_weight();
}
inline void FUbaJob::_internal_set_weight(float value) {
  
  weight_ = value;
}
inline void FUbaJob::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:FUbaJob.weight)
}

// string knownInputs = 10;
inline void FUbaJob::clear_knowninputs() {
  knowninputs_.ClearToEmpty();
}
inline const std::string& FUbaJob::knowninputs() const {
  // @@protoc_insertion_point(field_get:FUbaJob.knownInputs)
  return _internal_knowninputs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaJob::set_knowninputs(ArgT0&& arg0, ArgT... args) {
 
 knowninputs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaJob.knownInputs)
}
inline std::string* FUbaJob::mutable_knowninputs() {
  std::string* _s = _internal_mutable_knowninputs();
  // @@protoc_insertion_point(field_mutable:FUbaJob.knownInputs)
  return _s;
}
inline const std::string& FUbaJob::_internal_knowninputs() const {
  return knowninputs_.Get();
}
inline void FUbaJob::_internal_set_knowninputs(const std::string& value) {
  
  knowninputs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaJob::_internal_mutable_knowninputs() {
  
  return knowninputs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaJob::release_knowninputs() {
  // @@protoc_insertion_point(field_release:FUbaJob.knownInputs)
  return knowninputs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaJob::set_allocated_knowninputs(std::string* knowninputs) {
  if (knowninputs != nullptr) {
    
  } else {
    
  }
  knowninputs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), knowninputs,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaJob.knownInputs)
}

// int32 jobId = 11;
inline void FUbaJob::clear_jobid() {
  jobid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FUbaJob::_internal_jobid() const {
  return jobid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FUbaJob::jobid() const {
  // @@protoc_insertion_point(field_get:FUbaJob.jobId)
  return _internal_jobid();
}
inline void FUbaJob::_internal_set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  jobid_ = value;
}
inline void FUbaJob::set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_jobid(value);
  // @@protoc_insertion_point(field_set:FUbaJob.jobId)
}

// -------------------------------------------------------------------

// FLogLine

// string text = 1;
inline void FLogLine::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& FLogLine::text() const {
  // @@protoc_insertion_point(field_get:FLogLine.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FLogLine::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FLogLine.text)
}
inline std::string* FLogLine::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:FLogLine.text)
  return _s;
}
inline const std::string& FLogLine::_internal_text() const {
  return text_.Get();
}
inline void FLogLine::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FLogLine::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FLogLine::release_text() {
  // @@protoc_insertion_point(field_release:FLogLine.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FLogLine::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FLogLine.text)
}

// .ELogType type = 2;
inline void FLogLine::clear_type() {
  type_ = 0;
}
inline ::ELogType FLogLine::_internal_type() const {
  return static_cast< ::ELogType >(type_);
}
inline ::ELogType FLogLine::type() const {
  // @@protoc_insertion_point(field_get:FLogLine.type)
  return _internal_type();
}
inline void FLogLine::_internal_set_type(::ELogType value) {
  
  type_ = value;
}
inline void FLogLine::set_type(::ELogType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:FLogLine.type)
}

// -------------------------------------------------------------------

// FUbaStats

// uint32 queued = 1;
inline void FUbaStats::clear_queued() {
  queued_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::_internal_queued() const {
  return queued_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::queued() const {
  // @@protoc_insertion_point(field_get:FUbaStats.queued)
  return _internal_queued();
}
inline void FUbaStats::_internal_set_queued(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  queued_ = value;
}
inline void FUbaStats::set_queued(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_queued(value);
  // @@protoc_insertion_point(field_set:FUbaStats.queued)
}

// uint32 activeLocal = 2;
inline void FUbaStats::clear_activelocal() {
  activelocal_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::_internal_activelocal() const {
  return activelocal_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::activelocal() const {
  // @@protoc_insertion_point(field_get:FUbaStats.activeLocal)
  return _internal_activelocal();
}
inline void FUbaStats::_internal_set_activelocal(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  activelocal_ = value;
}
inline void FUbaStats::set_activelocal(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_activelocal(value);
  // @@protoc_insertion_point(field_set:FUbaStats.activeLocal)
}

// uint32 activeRemote = 3;
inline void FUbaStats::clear_activeremote() {
  activeremote_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::_internal_activeremote() const {
  return activeremote_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::activeremote() const {
  // @@protoc_insertion_point(field_get:FUbaStats.activeRemote)
  return _internal_activeremote();
}
inline void FUbaStats::_internal_set_activeremote(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  activeremote_ = value;
}
inline void FUbaStats::set_activeremote(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_activeremote(value);
  // @@protoc_insertion_point(field_set:FUbaStats.activeRemote)
}

// uint32 finished = 4;
inline void FUbaStats::clear_finished() {
  finished_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::_internal_finished() const {
  return finished_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FUbaStats::finished() const {
  // @@protoc_insertion_point(field_get:FUbaStats.finished)
  return _internal_finished();
}
inline void FUbaStats::_internal_set_finished(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  finished_ = value;
}
inline void FUbaStats::set_finished(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_finished(value);
  // @@protoc_insertion_point(field_set:FUbaStats.finished)
}

// -------------------------------------------------------------------

// FUbaOutput

// int32 exitCode = 1;
inline void FUbaOutput::clear_exitcode() {
  exitcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FUbaOutput::_internal_exitcode() const {
  return exitcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FUbaOutput::exitcode() const {
  // @@protoc_insertion_point(field_get:FUbaOutput.exitCode)
  return _internal_exitcode();
}
inline void FUbaOutput::_internal_set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exitcode_ = value;
}
inline void FUbaOutput::set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exitcode(value);
  // @@protoc_insertion_point(field_set:FUbaOutput.exitCode)
}

// string outputs = 2;
inline void FUbaOutput::clear_outputs() {
  outputs_.ClearToEmpty();
}
inline const std::string& FUbaOutput::outputs() const {
  // @@protoc_insertion_point(field_get:FUbaOutput.outputs)
  return _internal_outputs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FUbaOutput::set_outputs(ArgT0&& arg0, ArgT... args) {
 
 outputs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FUbaOutput.outputs)
}
inline std::string* FUbaOutput::mutable_outputs() {
  std::string* _s = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:FUbaOutput.outputs)
  return _s;
}
inline const std::string& FUbaOutput::_internal_outputs() const {
  return outputs_.Get();
}
inline void FUbaOutput::_internal_set_outputs(const std::string& value) {
  
  outputs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FUbaOutput::_internal_mutable_outputs() {
  
  return outputs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FUbaOutput::release_outputs() {
  // @@protoc_insertion_point(field_release:FUbaOutput.outputs)
  return outputs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FUbaOutput::set_allocated_outputs(std::string* outputs) {
  if (outputs != nullptr) {
    
  } else {
    
  }
  outputs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), outputs,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FUbaOutput.outputs)
}

// .FUbaStats stats = 3;
inline bool FUbaOutput::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool FUbaOutput::has_stats() const {
  return _internal_has_stats();
}
inline void FUbaOutput::clear_stats() {
  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
inline const ::FUbaStats& FUbaOutput::_internal_stats() const {
  const ::FUbaStats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::FUbaStats&>(
      ::_FUbaStats_default_instance_);
}
inline const ::FUbaStats& FUbaOutput::stats() const {
  // @@protoc_insertion_point(field_get:FUbaOutput.stats)
  return _internal_stats();
}
inline void FUbaOutput::unsafe_arena_set_allocated_stats(
    ::FUbaStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FUbaOutput.stats)
}
inline ::FUbaStats* FUbaOutput::release_stats() {
  
  ::FUbaStats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FUbaStats* FUbaOutput::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:FUbaOutput.stats)
  
  ::FUbaStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::FUbaStats* FUbaOutput::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::FUbaStats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::FUbaStats* FUbaOutput::mutable_stats() {
  ::FUbaStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:FUbaOutput.stats)
  return _msg;
}
inline void FUbaOutput::set_allocated_stats(::FUbaStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FUbaStats>::GetOwningArena(stats);
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:FUbaOutput.stats)
}

// int32 jobId = 4;
inline void FUbaOutput::clear_jobid() {
  jobid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FUbaOutput::_internal_jobid() const {
  return jobid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FUbaOutput::jobid() const {
  // @@protoc_insertion_point(field_get:FUbaOutput.jobId)
  return _internal_jobid();
}
inline void FUbaOutput::_internal_set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  jobid_ = value;
}
inline void FUbaOutput::set_jobid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_jobid(value);
  // @@protoc_insertion_point(field_set:FUbaOutput.jobId)
}

// -------------------------------------------------------------------

// FUbaExit

// bool bExit = 1;
inline void FUbaExit::clear_bexit() {
  bexit_ = false;
}
inline bool FUbaExit::_internal_bexit() const {
  return bexit_;
}
inline bool FUbaExit::bexit() const {
  // @@protoc_insertion_point(field_get:FUbaExit.bExit)
  return _internal_bexit();
}
inline void FUbaExit::_internal_set_bexit(bool value) {
  
  bexit_ = value;
}
inline void FUbaExit::set_bexit(bool value) {
  _internal_set_bexit(value);
  // @@protoc_insertion_point(field_set:FUbaExit.bExit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ELogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELogType>() {
  return ::ELogType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_uba_5fjob_2eproto

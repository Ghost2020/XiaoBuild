// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xiao_msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_xiao_5fmsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_xiao_5fmsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_xiao_5fmsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_xiao_5fmsg_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_xiao_5fmsg_2eproto;
class FAgentStatCore;
struct FAgentStatCoreDefaultTypeInternal;
extern FAgentStatCoreDefaultTypeInternal _FAgentStatCore_default_instance_;
class FCoreStatus;
struct FCoreStatusDefaultTypeInternal;
extern FCoreStatusDefaultTypeInternal _FCoreStatus_default_instance_;
class FRemoteTaskDesc;
struct FRemoteTaskDescDefaultTypeInternal;
extern FRemoteTaskDescDefaultTypeInternal _FRemoteTaskDesc_default_instance_;
class FXiaoMsg;
struct FXiaoMsgDefaultTypeInternal;
extern FXiaoMsgDefaultTypeInternal _FXiaoMsg_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::FAgentStatCore* Arena::CreateMaybeMessage<::FAgentStatCore>(Arena*);
template<> ::FCoreStatus* Arena::CreateMaybeMessage<::FCoreStatus>(Arena*);
template<> ::FRemoteTaskDesc* Arena::CreateMaybeMessage<::FRemoteTaskDesc>(Arena*);
template<> ::FXiaoMsg* Arena::CreateMaybeMessage<::FXiaoMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum EXiaoMsgType : int {
  Xmt_Undefined = 0,
  Xmt_KeepAlive = 1,
  Xmt_Accepted = 2,
  Xmt_Declined = 3,
  Xmt_TryConnect = 4,
  Xmt_TaskDesc = 5,
  Xmt_TaskKill = 6,
  Xmt_Disconnect = 7,
  Xmt_Data = 8,
  Xmt_EchoAcceptFullData = 9,
  Xmt_EchoAcceptBrokenData = 10,
  Xmt_ReSendData = 11,
  Xmt_AgentAcceptConnect = 12,
  Xmt_AgentDeclinedConnect = 13,
  Xmt_AgentStat = 14,
  Xmt_AgentRunTask = 15,
  Xmt_AgentOutputLog = 16,
  Xmt_AgentOutput = 17,
  Xmt_AgentFailed = 18,
  Xmt_AgentRestart = 19,
  Xmt_AgentDisconnect = 20,
  EXiaoMsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EXiaoMsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EXiaoMsgType_IsValid(int value);
constexpr EXiaoMsgType EXiaoMsgType_MIN = Xmt_Undefined;
constexpr EXiaoMsgType EXiaoMsgType_MAX = Xmt_AgentDisconnect;
constexpr int EXiaoMsgType_ARRAYSIZE = EXiaoMsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EXiaoMsgType_descriptor();
template<typename T>
inline const std::string& EXiaoMsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EXiaoMsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EXiaoMsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EXiaoMsgType_descriptor(), enum_t_value);
}
inline bool EXiaoMsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EXiaoMsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EXiaoMsgType>(
    EXiaoMsgType_descriptor(), name, value);
}
enum EXiaoDataType : int {
  Xdt_UnDefined = 0,
  Xdt_Binary = 1,
  EXiaoDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EXiaoDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EXiaoDataType_IsValid(int value);
constexpr EXiaoDataType EXiaoDataType_MIN = Xdt_UnDefined;
constexpr EXiaoDataType EXiaoDataType_MAX = Xdt_Binary;
constexpr int EXiaoDataType_ARRAYSIZE = EXiaoDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EXiaoDataType_descriptor();
template<typename T>
inline const std::string& EXiaoDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EXiaoDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EXiaoDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EXiaoDataType_descriptor(), enum_t_value);
}
inline bool EXiaoDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EXiaoDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EXiaoDataType>(
    EXiaoDataType_descriptor(), name, value);
}
// ===================================================================

class FRemoteTaskDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FRemoteTaskDesc) */ {
 public:
  inline FRemoteTaskDesc() : FRemoteTaskDesc(nullptr) {}
  ~FRemoteTaskDesc() override;
  explicit constexpr FRemoteTaskDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FRemoteTaskDesc(const FRemoteTaskDesc& from);
  FRemoteTaskDesc(FRemoteTaskDesc&& from) noexcept
    : FRemoteTaskDesc() {
    *this = ::std::move(from);
  }

  inline FRemoteTaskDesc& operator=(const FRemoteTaskDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline FRemoteTaskDesc& operator=(FRemoteTaskDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FRemoteTaskDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const FRemoteTaskDesc* internal_default_instance() {
    return reinterpret_cast<const FRemoteTaskDesc*>(
               &_FRemoteTaskDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FRemoteTaskDesc& a, FRemoteTaskDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(FRemoteTaskDesc* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FRemoteTaskDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FRemoteTaskDesc* New() const final {
    return new FRemoteTaskDesc();
  }

  FRemoteTaskDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FRemoteTaskDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FRemoteTaskDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FRemoteTaskDesc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FRemoteTaskDesc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FRemoteTaskDesc";
  }
  protected:
  explicit FRemoteTaskDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGUIDFieldNumber = 1,
    kProcFieldNumber = 2,
    kParamsFieldNumber = 3,
    kWorkingDirFieldNumber = 4,
    kPriorityFieldNumber = 5,
    kCoreIndexFieldNumber = 6,
  };
  // string GUID = 1;
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_MUST_USE_RESULT std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // string Proc = 2;
  void clear_proc();
  const std::string& proc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proc();
  PROTOBUF_MUST_USE_RESULT std::string* release_proc();
  void set_allocated_proc(std::string* proc);
  private:
  const std::string& _internal_proc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proc(const std::string& value);
  std::string* _internal_mutable_proc();
  public:

  // string Params = 3;
  void clear_params();
  const std::string& params() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_params(ArgT0&& arg0, ArgT... args);
  std::string* mutable_params();
  PROTOBUF_MUST_USE_RESULT std::string* release_params();
  void set_allocated_params(std::string* params);
  private:
  const std::string& _internal_params() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_params(const std::string& value);
  std::string* _internal_mutable_params();
  public:

  // string WorkingDir = 4;
  void clear_workingdir();
  const std::string& workingdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workingdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workingdir();
  PROTOBUF_MUST_USE_RESULT std::string* release_workingdir();
  void set_allocated_workingdir(std::string* workingdir);
  private:
  const std::string& _internal_workingdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workingdir(const std::string& value);
  std::string* _internal_mutable_workingdir();
  public:

  // int32 Priority = 5;
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::int32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 CoreIndex = 6;
  void clear_coreindex();
  ::PROTOBUF_NAMESPACE_ID::int32 coreindex() const;
  void set_coreindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_coreindex() const;
  void _internal_set_coreindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:FRemoteTaskDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr params_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workingdir_;
  ::PROTOBUF_NAMESPACE_ID::int32 priority_;
  ::PROTOBUF_NAMESPACE_ID::int32 coreindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xiao_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class FCoreStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FCoreStatus) */ {
 public:
  inline FCoreStatus() : FCoreStatus(nullptr) {}
  ~FCoreStatus() override;
  explicit constexpr FCoreStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FCoreStatus(const FCoreStatus& from);
  FCoreStatus(FCoreStatus&& from) noexcept
    : FCoreStatus() {
    *this = ::std::move(from);
  }

  inline FCoreStatus& operator=(const FCoreStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FCoreStatus& operator=(FCoreStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FCoreStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FCoreStatus* internal_default_instance() {
    return reinterpret_cast<const FCoreStatus*>(
               &_FCoreStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FCoreStatus& a, FCoreStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(FCoreStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FCoreStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FCoreStatus* New() const final {
    return new FCoreStatus();
  }

  FCoreStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FCoreStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FCoreStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FCoreStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FCoreStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FCoreStatus";
  }
  protected:
  explicit FCoreStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kStatusFieldNumber = 2,
    kLastActiveTimeFieldNumber = 3,
  };
  // int32 Index = 1;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool Status = 2;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // float LastActiveTime = 3;
  void clear_lastactivetime();
  float lastactivetime() const;
  void set_lastactivetime(float value);
  private:
  float _internal_lastactivetime() const;
  void _internal_set_lastactivetime(float value);
  public:

  // @@protoc_insertion_point(class_scope:FCoreStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  bool status_;
  float lastactivetime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xiao_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class FAgentStatCore final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FAgentStatCore) */ {
 public:
  inline FAgentStatCore() : FAgentStatCore(nullptr) {}
  ~FAgentStatCore() override;
  explicit constexpr FAgentStatCore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FAgentStatCore(const FAgentStatCore& from);
  FAgentStatCore(FAgentStatCore&& from) noexcept
    : FAgentStatCore() {
    *this = ::std::move(from);
  }

  inline FAgentStatCore& operator=(const FAgentStatCore& from) {
    CopyFrom(from);
    return *this;
  }
  inline FAgentStatCore& operator=(FAgentStatCore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FAgentStatCore& default_instance() {
    return *internal_default_instance();
  }
  static inline const FAgentStatCore* internal_default_instance() {
    return reinterpret_cast<const FAgentStatCore*>(
               &_FAgentStatCore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FAgentStatCore& a, FAgentStatCore& b) {
    a.Swap(&b);
  }
  inline void Swap(FAgentStatCore* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FAgentStatCore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FAgentStatCore* New() const final {
    return new FAgentStatCore();
  }

  FAgentStatCore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FAgentStatCore>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FAgentStatCore& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FAgentStatCore& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FAgentStatCore* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FAgentStatCore";
  }
  protected:
  explicit FAgentStatCore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoresFieldNumber = 3,
    kCpuAvaFieldNumber = 1,
    kHardAvaFieldNumber = 2,
  };
  // repeated .FCoreStatus Cores = 3;
  int cores_size() const;
  private:
  int _internal_cores_size() const;
  public:
  void clear_cores();
  ::FCoreStatus* mutable_cores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FCoreStatus >*
      mutable_cores();
  private:
  const ::FCoreStatus& _internal_cores(int index) const;
  ::FCoreStatus* _internal_add_cores();
  public:
  const ::FCoreStatus& cores(int index) const;
  ::FCoreStatus* add_cores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FCoreStatus >&
      cores() const;

  // float CpuAva = 1;
  void clear_cpuava();
  float cpuava() const;
  void set_cpuava(float value);
  private:
  float _internal_cpuava() const;
  void _internal_set_cpuava(float value);
  public:

  // float HardAva = 2;
  void clear_hardava();
  float hardava() const;
  void set_hardava(float value);
  private:
  float _internal_hardava() const;
  void _internal_set_hardava(float value);
  public:

  // @@protoc_insertion_point(class_scope:FAgentStatCore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FCoreStatus > cores_;
  float cpuava_;
  float hardava_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xiao_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class FXiaoMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FXiaoMsg) */ {
 public:
  inline FXiaoMsg() : FXiaoMsg(nullptr) {}
  ~FXiaoMsg() override;
  explicit constexpr FXiaoMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FXiaoMsg(const FXiaoMsg& from);
  FXiaoMsg(FXiaoMsg&& from) noexcept
    : FXiaoMsg() {
    *this = ::std::move(from);
  }

  inline FXiaoMsg& operator=(const FXiaoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FXiaoMsg& operator=(FXiaoMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FXiaoMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const FXiaoMsg* internal_default_instance() {
    return reinterpret_cast<const FXiaoMsg*>(
               &_FXiaoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FXiaoMsg& a, FXiaoMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(FXiaoMsg* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FXiaoMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FXiaoMsg* New() const final {
    return new FXiaoMsg();
  }

  FXiaoMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FXiaoMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FXiaoMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FXiaoMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FXiaoMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FXiaoMsg";
  }
  protected:
  explicit FXiaoMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kMsgFieldNumber = 5,
    kTaskDescFieldNumber = 4,
    kStatsFieldNumber = 6,
    kTypeFieldNumber = 1,
    kBEchoFieldNumber = 3,
  };
  // string Id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string Msg = 5;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .FRemoteTaskDesc TaskDesc = 4;
  bool has_taskdesc() const;
  private:
  bool _internal_has_taskdesc() const;
  public:
  void clear_taskdesc();
  const ::FRemoteTaskDesc& taskdesc() const;
  PROTOBUF_MUST_USE_RESULT ::FRemoteTaskDesc* release_taskdesc();
  ::FRemoteTaskDesc* mutable_taskdesc();
  void set_allocated_taskdesc(::FRemoteTaskDesc* taskdesc);
  private:
  const ::FRemoteTaskDesc& _internal_taskdesc() const;
  ::FRemoteTaskDesc* _internal_mutable_taskdesc();
  public:
  void unsafe_arena_set_allocated_taskdesc(
      ::FRemoteTaskDesc* taskdesc);
  ::FRemoteTaskDesc* unsafe_arena_release_taskdesc();

  // .FAgentStatCore Stats = 6;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::FAgentStatCore& stats() const;
  PROTOBUF_MUST_USE_RESULT ::FAgentStatCore* release_stats();
  ::FAgentStatCore* mutable_stats();
  void set_allocated_stats(::FAgentStatCore* stats);
  private:
  const ::FAgentStatCore& _internal_stats() const;
  ::FAgentStatCore* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::FAgentStatCore* stats);
  ::FAgentStatCore* unsafe_arena_release_stats();

  // .EXiaoMsgType Type = 1;
  void clear_type();
  ::EXiaoMsgType type() const;
  void set_type(::EXiaoMsgType value);
  private:
  ::EXiaoMsgType _internal_type() const;
  void _internal_set_type(::EXiaoMsgType value);
  public:

  // bool bEcho = 3;
  void clear_becho();
  bool becho() const;
  void set_becho(bool value);
  private:
  bool _internal_becho() const;
  void _internal_set_becho(bool value);
  public:

  // @@protoc_insertion_point(class_scope:FXiaoMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::FRemoteTaskDesc* taskdesc_;
  ::FAgentStatCore* stats_;
  int type_;
  bool becho_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xiao_5fmsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FRemoteTaskDesc

// string GUID = 1;
inline void FRemoteTaskDesc::clear_guid() {
  guid_.ClearToEmpty();
}
inline const std::string& FRemoteTaskDesc::guid() const {
  // @@protoc_insertion_point(field_get:FRemoteTaskDesc.GUID)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FRemoteTaskDesc::set_guid(ArgT0&& arg0, ArgT... args) {
 
 guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FRemoteTaskDesc.GUID)
}
inline std::string* FRemoteTaskDesc::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:FRemoteTaskDesc.GUID)
  return _s;
}
inline const std::string& FRemoteTaskDesc::_internal_guid() const {
  return guid_.Get();
}
inline void FRemoteTaskDesc::_internal_set_guid(const std::string& value) {
  
  guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::_internal_mutable_guid() {
  
  return guid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::release_guid() {
  // @@protoc_insertion_point(field_release:FRemoteTaskDesc.GUID)
  return guid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FRemoteTaskDesc::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    
  } else {
    
  }
  guid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FRemoteTaskDesc.GUID)
}

// string Proc = 2;
inline void FRemoteTaskDesc::clear_proc() {
  proc_.ClearToEmpty();
}
inline const std::string& FRemoteTaskDesc::proc() const {
  // @@protoc_insertion_point(field_get:FRemoteTaskDesc.Proc)
  return _internal_proc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FRemoteTaskDesc::set_proc(ArgT0&& arg0, ArgT... args) {
 
 proc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FRemoteTaskDesc.Proc)
}
inline std::string* FRemoteTaskDesc::mutable_proc() {
  std::string* _s = _internal_mutable_proc();
  // @@protoc_insertion_point(field_mutable:FRemoteTaskDesc.Proc)
  return _s;
}
inline const std::string& FRemoteTaskDesc::_internal_proc() const {
  return proc_.Get();
}
inline void FRemoteTaskDesc::_internal_set_proc(const std::string& value) {
  
  proc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::_internal_mutable_proc() {
  
  return proc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::release_proc() {
  // @@protoc_insertion_point(field_release:FRemoteTaskDesc.Proc)
  return proc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FRemoteTaskDesc::set_allocated_proc(std::string* proc) {
  if (proc != nullptr) {
    
  } else {
    
  }
  proc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FRemoteTaskDesc.Proc)
}

// string Params = 3;
inline void FRemoteTaskDesc::clear_params() {
  params_.ClearToEmpty();
}
inline const std::string& FRemoteTaskDesc::params() const {
  // @@protoc_insertion_point(field_get:FRemoteTaskDesc.Params)
  return _internal_params();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FRemoteTaskDesc::set_params(ArgT0&& arg0, ArgT... args) {
 
 params_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FRemoteTaskDesc.Params)
}
inline std::string* FRemoteTaskDesc::mutable_params() {
  std::string* _s = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:FRemoteTaskDesc.Params)
  return _s;
}
inline const std::string& FRemoteTaskDesc::_internal_params() const {
  return params_.Get();
}
inline void FRemoteTaskDesc::_internal_set_params(const std::string& value) {
  
  params_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::_internal_mutable_params() {
  
  return params_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::release_params() {
  // @@protoc_insertion_point(field_release:FRemoteTaskDesc.Params)
  return params_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FRemoteTaskDesc::set_allocated_params(std::string* params) {
  if (params != nullptr) {
    
  } else {
    
  }
  params_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), params,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FRemoteTaskDesc.Params)
}

// string WorkingDir = 4;
inline void FRemoteTaskDesc::clear_workingdir() {
  workingdir_.ClearToEmpty();
}
inline const std::string& FRemoteTaskDesc::workingdir() const {
  // @@protoc_insertion_point(field_get:FRemoteTaskDesc.WorkingDir)
  return _internal_workingdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FRemoteTaskDesc::set_workingdir(ArgT0&& arg0, ArgT... args) {
 
 workingdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FRemoteTaskDesc.WorkingDir)
}
inline std::string* FRemoteTaskDesc::mutable_workingdir() {
  std::string* _s = _internal_mutable_workingdir();
  // @@protoc_insertion_point(field_mutable:FRemoteTaskDesc.WorkingDir)
  return _s;
}
inline const std::string& FRemoteTaskDesc::_internal_workingdir() const {
  return workingdir_.Get();
}
inline void FRemoteTaskDesc::_internal_set_workingdir(const std::string& value) {
  
  workingdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::_internal_mutable_workingdir() {
  
  return workingdir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FRemoteTaskDesc::release_workingdir() {
  // @@protoc_insertion_point(field_release:FRemoteTaskDesc.WorkingDir)
  return workingdir_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FRemoteTaskDesc::set_allocated_workingdir(std::string* workingdir) {
  if (workingdir != nullptr) {
    
  } else {
    
  }
  workingdir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workingdir,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FRemoteTaskDesc.WorkingDir)
}

// int32 Priority = 5;
inline void FRemoteTaskDesc::clear_priority() {
  priority_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FRemoteTaskDesc::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FRemoteTaskDesc::priority() const {
  // @@protoc_insertion_point(field_get:FRemoteTaskDesc.Priority)
  return _internal_priority();
}
inline void FRemoteTaskDesc::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  priority_ = value;
}
inline void FRemoteTaskDesc::set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:FRemoteTaskDesc.Priority)
}

// int32 CoreIndex = 6;
inline void FRemoteTaskDesc::clear_coreindex() {
  coreindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FRemoteTaskDesc::_internal_coreindex() const {
  return coreindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FRemoteTaskDesc::coreindex() const {
  // @@protoc_insertion_point(field_get:FRemoteTaskDesc.CoreIndex)
  return _internal_coreindex();
}
inline void FRemoteTaskDesc::_internal_set_coreindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  coreindex_ = value;
}
inline void FRemoteTaskDesc::set_coreindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_coreindex(value);
  // @@protoc_insertion_point(field_set:FRemoteTaskDesc.CoreIndex)
}

// -------------------------------------------------------------------

// FCoreStatus

// int32 Index = 1;
inline void FCoreStatus::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FCoreStatus::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FCoreStatus::index() const {
  // @@protoc_insertion_point(field_get:FCoreStatus.Index)
  return _internal_index();
}
inline void FCoreStatus::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void FCoreStatus::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:FCoreStatus.Index)
}

// bool Status = 2;
inline void FCoreStatus::clear_status() {
  status_ = false;
}
inline bool FCoreStatus::_internal_status() const {
  return status_;
}
inline bool FCoreStatus::status() const {
  // @@protoc_insertion_point(field_get:FCoreStatus.Status)
  return _internal_status();
}
inline void FCoreStatus::_internal_set_status(bool value) {
  
  status_ = value;
}
inline void FCoreStatus::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:FCoreStatus.Status)
}

// float LastActiveTime = 3;
inline void FCoreStatus::clear_lastactivetime() {
  lastactivetime_ = 0;
}
inline float FCoreStatus::_internal_lastactivetime() const {
  return lastactivetime_;
}
inline float FCoreStatus::lastactivetime() const {
  // @@protoc_insertion_point(field_get:FCoreStatus.LastActiveTime)
  return _internal_lastactivetime();
}
inline void FCoreStatus::_internal_set_lastactivetime(float value) {
  
  lastactivetime_ = value;
}
inline void FCoreStatus::set_lastactivetime(float value) {
  _internal_set_lastactivetime(value);
  // @@protoc_insertion_point(field_set:FCoreStatus.LastActiveTime)
}

// -------------------------------------------------------------------

// FAgentStatCore

// float CpuAva = 1;
inline void FAgentStatCore::clear_cpuava() {
  cpuava_ = 0;
}
inline float FAgentStatCore::_internal_cpuava() const {
  return cpuava_;
}
inline float FAgentStatCore::cpuava() const {
  // @@protoc_insertion_point(field_get:FAgentStatCore.CpuAva)
  return _internal_cpuava();
}
inline void FAgentStatCore::_internal_set_cpuava(float value) {
  
  cpuava_ = value;
}
inline void FAgentStatCore::set_cpuava(float value) {
  _internal_set_cpuava(value);
  // @@protoc_insertion_point(field_set:FAgentStatCore.CpuAva)
}

// float HardAva = 2;
inline void FAgentStatCore::clear_hardava() {
  hardava_ = 0;
}
inline float FAgentStatCore::_internal_hardava() const {
  return hardava_;
}
inline float FAgentStatCore::hardava() const {
  // @@protoc_insertion_point(field_get:FAgentStatCore.HardAva)
  return _internal_hardava();
}
inline void FAgentStatCore::_internal_set_hardava(float value) {
  
  hardava_ = value;
}
inline void FAgentStatCore::set_hardava(float value) {
  _internal_set_hardava(value);
  // @@protoc_insertion_point(field_set:FAgentStatCore.HardAva)
}

// repeated .FCoreStatus Cores = 3;
inline int FAgentStatCore::_internal_cores_size() const {
  return cores_.size();
}
inline int FAgentStatCore::cores_size() const {
  return _internal_cores_size();
}
inline void FAgentStatCore::clear_cores() {
  cores_.Clear();
}
inline ::FCoreStatus* FAgentStatCore::mutable_cores(int index) {
  // @@protoc_insertion_point(field_mutable:FAgentStatCore.Cores)
  return cores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FCoreStatus >*
FAgentStatCore::mutable_cores() {
  // @@protoc_insertion_point(field_mutable_list:FAgentStatCore.Cores)
  return &cores_;
}
inline const ::FCoreStatus& FAgentStatCore::_internal_cores(int index) const {
  return cores_.Get(index);
}
inline const ::FCoreStatus& FAgentStatCore::cores(int index) const {
  // @@protoc_insertion_point(field_get:FAgentStatCore.Cores)
  return _internal_cores(index);
}
inline ::FCoreStatus* FAgentStatCore::_internal_add_cores() {
  return cores_.Add();
}
inline ::FCoreStatus* FAgentStatCore::add_cores() {
  ::FCoreStatus* _add = _internal_add_cores();
  // @@protoc_insertion_point(field_add:FAgentStatCore.Cores)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FCoreStatus >&
FAgentStatCore::cores() const {
  // @@protoc_insertion_point(field_list:FAgentStatCore.Cores)
  return cores_;
}

// -------------------------------------------------------------------

// FXiaoMsg

// .EXiaoMsgType Type = 1;
inline void FXiaoMsg::clear_type() {
  type_ = 0;
}
inline ::EXiaoMsgType FXiaoMsg::_internal_type() const {
  return static_cast< ::EXiaoMsgType >(type_);
}
inline ::EXiaoMsgType FXiaoMsg::type() const {
  // @@protoc_insertion_point(field_get:FXiaoMsg.Type)
  return _internal_type();
}
inline void FXiaoMsg::_internal_set_type(::EXiaoMsgType value) {
  
  type_ = value;
}
inline void FXiaoMsg::set_type(::EXiaoMsgType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:FXiaoMsg.Type)
}

// string Id = 2;
inline void FXiaoMsg::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& FXiaoMsg::id() const {
  // @@protoc_insertion_point(field_get:FXiaoMsg.Id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FXiaoMsg::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FXiaoMsg.Id)
}
inline std::string* FXiaoMsg::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:FXiaoMsg.Id)
  return _s;
}
inline const std::string& FXiaoMsg::_internal_id() const {
  return id_.Get();
}
inline void FXiaoMsg::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FXiaoMsg::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FXiaoMsg::release_id() {
  // @@protoc_insertion_point(field_release:FXiaoMsg.Id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FXiaoMsg::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FXiaoMsg.Id)
}

// bool bEcho = 3;
inline void FXiaoMsg::clear_becho() {
  becho_ = false;
}
inline bool FXiaoMsg::_internal_becho() const {
  return becho_;
}
inline bool FXiaoMsg::becho() const {
  // @@protoc_insertion_point(field_get:FXiaoMsg.bEcho)
  return _internal_becho();
}
inline void FXiaoMsg::_internal_set_becho(bool value) {
  
  becho_ = value;
}
inline void FXiaoMsg::set_becho(bool value) {
  _internal_set_becho(value);
  // @@protoc_insertion_point(field_set:FXiaoMsg.bEcho)
}

// .FRemoteTaskDesc TaskDesc = 4;
inline bool FXiaoMsg::_internal_has_taskdesc() const {
  return this != internal_default_instance() && taskdesc_ != nullptr;
}
inline bool FXiaoMsg::has_taskdesc() const {
  return _internal_has_taskdesc();
}
inline void FXiaoMsg::clear_taskdesc() {
  if (GetArenaForAllocation() == nullptr && taskdesc_ != nullptr) {
    delete taskdesc_;
  }
  taskdesc_ = nullptr;
}
inline const ::FRemoteTaskDesc& FXiaoMsg::_internal_taskdesc() const {
  const ::FRemoteTaskDesc* p = taskdesc_;
  return p != nullptr ? *p : reinterpret_cast<const ::FRemoteTaskDesc&>(
      ::_FRemoteTaskDesc_default_instance_);
}
inline const ::FRemoteTaskDesc& FXiaoMsg::taskdesc() const {
  // @@protoc_insertion_point(field_get:FXiaoMsg.TaskDesc)
  return _internal_taskdesc();
}
inline void FXiaoMsg::unsafe_arena_set_allocated_taskdesc(
    ::FRemoteTaskDesc* taskdesc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(taskdesc_);
  }
  taskdesc_ = taskdesc;
  if (taskdesc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FXiaoMsg.TaskDesc)
}
inline ::FRemoteTaskDesc* FXiaoMsg::release_taskdesc() {
  
  ::FRemoteTaskDesc* temp = taskdesc_;
  taskdesc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FRemoteTaskDesc* FXiaoMsg::unsafe_arena_release_taskdesc() {
  // @@protoc_insertion_point(field_release:FXiaoMsg.TaskDesc)
  
  ::FRemoteTaskDesc* temp = taskdesc_;
  taskdesc_ = nullptr;
  return temp;
}
inline ::FRemoteTaskDesc* FXiaoMsg::_internal_mutable_taskdesc() {
  
  if (taskdesc_ == nullptr) {
    auto* p = CreateMaybeMessage<::FRemoteTaskDesc>(GetArenaForAllocation());
    taskdesc_ = p;
  }
  return taskdesc_;
}
inline ::FRemoteTaskDesc* FXiaoMsg::mutable_taskdesc() {
  ::FRemoteTaskDesc* _msg = _internal_mutable_taskdesc();
  // @@protoc_insertion_point(field_mutable:FXiaoMsg.TaskDesc)
  return _msg;
}
inline void FXiaoMsg::set_allocated_taskdesc(::FRemoteTaskDesc* taskdesc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete taskdesc_;
  }
  if (taskdesc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FRemoteTaskDesc>::GetOwningArena(taskdesc);
    if (message_arena != submessage_arena) {
      taskdesc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taskdesc, submessage_arena);
    }
    
  } else {
    
  }
  taskdesc_ = taskdesc;
  // @@protoc_insertion_point(field_set_allocated:FXiaoMsg.TaskDesc)
}

// string Msg = 5;
inline void FXiaoMsg::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& FXiaoMsg::msg() const {
  // @@protoc_insertion_point(field_get:FXiaoMsg.Msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FXiaoMsg::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FXiaoMsg.Msg)
}
inline std::string* FXiaoMsg::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:FXiaoMsg.Msg)
  return _s;
}
inline const std::string& FXiaoMsg::_internal_msg() const {
  return msg_.Get();
}
inline void FXiaoMsg::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FXiaoMsg::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FXiaoMsg::release_msg() {
  // @@protoc_insertion_point(field_release:FXiaoMsg.Msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FXiaoMsg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FXiaoMsg.Msg)
}

// .FAgentStatCore Stats = 6;
inline bool FXiaoMsg::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool FXiaoMsg::has_stats() const {
  return _internal_has_stats();
}
inline void FXiaoMsg::clear_stats() {
  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
inline const ::FAgentStatCore& FXiaoMsg::_internal_stats() const {
  const ::FAgentStatCore* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::FAgentStatCore&>(
      ::_FAgentStatCore_default_instance_);
}
inline const ::FAgentStatCore& FXiaoMsg::stats() const {
  // @@protoc_insertion_point(field_get:FXiaoMsg.Stats)
  return _internal_stats();
}
inline void FXiaoMsg::unsafe_arena_set_allocated_stats(
    ::FAgentStatCore* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FXiaoMsg.Stats)
}
inline ::FAgentStatCore* FXiaoMsg::release_stats() {
  
  ::FAgentStatCore* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FAgentStatCore* FXiaoMsg::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:FXiaoMsg.Stats)
  
  ::FAgentStatCore* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::FAgentStatCore* FXiaoMsg::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::FAgentStatCore>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::FAgentStatCore* FXiaoMsg::mutable_stats() {
  ::FAgentStatCore* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:FXiaoMsg.Stats)
  return _msg;
}
inline void FXiaoMsg::set_allocated_stats(::FAgentStatCore* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FAgentStatCore>::GetOwningArena(stats);
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:FXiaoMsg.Stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EXiaoMsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EXiaoMsgType>() {
  return ::EXiaoMsgType_descriptor();
}
template <> struct is_proto_enum< ::EXiaoDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EXiaoDataType>() {
  return ::EXiaoDataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_xiao_5fmsg_2eproto
